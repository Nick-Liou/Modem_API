# Generated by Selenium IDE
import json
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from selenium.common.exceptions import ElementClickInterceptedException

class Modem():

  wifi_name_to_int = {  "2.4G"        : 0 ,
                        "5G"          : 1 ,
                        "Guest 2.4G"  : 2 ,
                        "Guest 5G"    : 3 }
  
  wifi_sliders = {  "2.4G"        : "#card_wifi .card-block > .card-text .slider"       , 
                    "5G"          : "#card_wifi .card-block > div > .card-text .slider" , 
                    "Guest 2.4G"  : "#card_guest .card-block > .card-text .slider"      , 
                    "Guest 5G"    : "#card_guest .card-block > div > .card-text .slider" }
  
  wifi_tuple = ( "2.4G" , "5G" , "Guest 2.4G" , "Guest 5G" )

  whitelisted_devices = ()
  

  

  def setup_method(self , headless = False):

    # headOption = webdriver.FirefoxOptions()
    # headOption.headless = headless
    # driver = webdriver.Firefox(options=headOption)
    headOption = webdriver.FirefoxOptions()
    if headless:
      headOption.add_argument("--headless")
    # driver = webdriver.Firefox(options=headOption)

    self.driver = webdriver.Firefox(options=headOption)
    self.wifi_status = [False, False , False , False]
    self.num_of_conected_devices = [0, 0]
    self.connected_devices = []   # a list of dicts of the type:  { "Name" : device_name   ,   "IP"   : device_IP     ,   "Mac"  : device_Mac    }
  
  def teardown_method(self):
    self.driver.quit()
  

    
  def open_and_login_to_modem(self, file_path_to_credentials = 'credentials.json'):
     
    # Specify the path to your JSON file
    file_path_to_credentials = 'credentials.json'

    self.driver.get("http://192.168.1.254/")
    # Open the file in read mode
    with open(file_path_to_credentials, 'r') as file:
        # Load the JSON data
        data = json.load(file)

        self.whitelisted_devices = data["whitelisted_devices"]["Mac_addresses"]
        username = data["username"]
        password = data["password"]


    
    # This is to press ok to the "you have been disconected" pop-up
    WebDriverWait(self.driver, 3).until(    EC.presence_of_element_located((By.CSS_SELECTOR, ".normalbtn > span")) ) 
    self.driver.find_element(By.CSS_SELECTOR, ".normalbtn > span").click()  # This is to press ok to the you have been disconected 
    
    # Auto_script_1
    # Km$Xg8ZpPujh
    WebDriverWait(self.driver, 10).until(    EC.presence_of_element_located((By.ID, "username")) )
    self.driver.find_element(By.ID, "username").click()
    self.driver.find_element(By.ID, "username").send_keys(username)
    self.driver.find_element(By.ID, "userpassword").click()
    self.driver.find_element(By.ID, "userpassword").send_keys(password)
    self.driver.find_element(By.CSS_SELECTOR, "#loginBtn > span").click()
  

  def toggle_Wifi (self , wifi_to_toggle = ["2.4G"] , print_results = False ):

    for i in wifi_to_toggle :       

      print(f"Toggling {i} ")
      self.driver.find_element(By.CSS_SELECTOR, Modem.wifi_sliders[i]  ).click()

      # Wait for the loading box to dissapear 
      loading_locator = self.driver.find_element(By.ID, "LoadingBox")
      
      # Set a maximum wait time (in seconds)
      max_wait_time = 60  # Adjust as needed
      # Wait for the loading spinner to disappear
      try:
          WebDriverWait(self.driver, max_wait_time).until(
              EC.invisibility_of_element_located(loading_locator)
          )
          print("Loading spinner has disappeared")
          time.sleep(1)
      except TimeoutException:
          print(f"Loading spinner did not disappear within the specified time ({max_wait_time} sec)")
        


    time.sleep(7)
    return self.check_wifi_status( print_results = print_results ) 
  

  def check_wifi_status(self , print_results = False ):
    
    wifi_ids = ["card_24gwifisetting" , "card_5gwifisetting" , "card_24guestwifisetting" , "card_5guestwifisetting" ]   


    # WebDriverWait(self.driver, 5).until(  EC.presence_of_element_located((By.ID, wifi_ids[0] ))  ) 

    for wifi_id,i in zip(wifi_ids,range(4)): 
      input_element = self.driver.find_element(By.ID, wifi_id )

      # Check the "checked" attribute of the <input> element
      slider_status = input_element.get_attribute("checked")
      # Determine the status of the slider based on the "checked" attribute
      self.wifi_status[i] = slider_status is not None


    # wifi_names = ["Wifi 2.4G" , "Wifi 5G" , "Guest Wifi 2.4G" , "Guest Wifi 5G"]
    # bool_to_on_off = [ "OFF" , "ON" ]
    # for i in range(4):
    #   print(f"{wifi_names[i]} is {bool_to_on_off[int(self.wifi_status[i])]}")

    if (print_results):
      self.print_status()

    return self.wifi_status
  
  def print_status (self):
    
    wifi_names = (  "Wifi 2.4G      " ,
                    "Wifi 5G        " ,
                    "Guest Wifi 2.4G" ,
                    "Guest Wifi 5G  " )    
    
    bool_to_on_off = ( "OFF" , "ON" )
    for i in range(4):
      print(f"{wifi_names[i]} is {bool_to_on_off[int(self.wifi_status[i])]}")
    
    print()
    pass


  def check_connected_devices(self , print_results = False):
    max_tries = 4

    WebDriverWait(self.driver, 5).until(  EC.presence_of_element_located((By.CSS_SELECTOR, "#card_cnt > .fa-2x")) ) 
    for _ in range( max_tries ):
      try:
        self.driver.find_element(By.CSS_SELECTOR, "#card_cnt > .fa-2x").click()
        break
      except ElementClickInterceptedException as error:
        # print(error)
        print("The element wasn't clickable, sleep 2 sec and try again")        
        time.sleep(2)
    
    
    time.sleep(4)



    # Locate the <span> elements with the class "tag"
    tag_elements = self.driver.find_elements(By.CLASS_NAME, "tag")
    # Find number of connected devices (there is a bug that makes the wifi connected devices appear as connected via wire)
    self.num_of_conected_devices[0] = int((tag_elements[0]).text)
    self.num_of_conected_devices[1] = int((tag_elements[1]).text)


    # Reset the connected devices
    self.connected_devices = []
    devices_found_number = 0
    i = 1
    while ( devices_found_number != self.num_of_conected_devices[0] ):
      try:
        element = self.driver.find_element(By.CSS_SELECTOR, f".wired > .col-xl-4:nth-child({i}) > .d-flex")
      except:
        self.check_connected_devices(print_results = print_results)
        return
      
      a = element.text
      # print("i = " , i )
      # print("a = " , a )

      i += 1 
      if a != "" :       
        # print(f"Element\"{a}\"")
        devices_found_number += 1
        device_name = a[                : a.find(" IP:")  ]
        device_IP   = a[a.find("IP:")   : a.find(" Mac:") ]
        device_Mac  = a[a.find("Mac:")  :                 ]

        self.connected_devices.append(  { "Name" : device_name   , 
                                          "IP"   : device_IP     ,
                                          "Mac"  : device_Mac    } )
        



    if ( self.num_of_conected_devices[1] != 0 ):

      # Change tab to see wifi connected devices
      # WebDriverWait(self.driver, 5).until(    EC.presence_of_element_located((By.CSS_SELECTOR,  "#Connectivity-tab-Wireless > span")) ) 
      self.driver.find_element(By.CSS_SELECTOR, "#Connectivity-tab-Wireless > span").click()

      # Get the devices connected via wifi

      for device in range(self.num_of_conected_devices[1]):
        element = self.driver.find_element(By.CSS_SELECTOR, f".wired > .col-xl-4:nth-child({device+1}) > .d-flex")
        a = element.text
        device_name = a[                : a.find(" IP:")  ]
        device_IP   = a[a.find("IP:")   : a.find(" Mac:") ]
        device_Mac  = a[a.find("Mac:")  :                 ]

        self.connected_devices.append(  { "Name" : device_name   , 
                                          "IP"   : device_IP     ,
                                          "Mac"  : device_Mac    } )



    # Exit connectivity tab, (go back to the main page)
    self.driver.find_element(By.CSS_SELECTOR, ".main-closebox > .icon").click()

    if print_results:
      self.print_connected_devices()

    return self.num_of_conected_devices[0] , self.num_of_conected_devices[1]
  
  def print_connected_devices(self , print_only_names = False):

    print("Number of connected devices")
    print(f"Wired: {self.num_of_conected_devices[0]}")
    print(f"Wifi:  {self.num_of_conected_devices[1]}")

    for i in range(len(self.connected_devices)):      
      if print_only_names :         
        print(f"Device {i} Name: {(self.connected_devices[i])['Name']}")
      else:
        print(f"\nDevice No {i}") 
        print(f"Device Name: {(self.connected_devices[i])['Name']}")
        print(f"Device IP:   {(self.connected_devices[i])['IP']}")
        print(f"Device Mac:  {(self.connected_devices[i])['Mac']}")
    
    print()


  
  def turn_wifi_on (self , wifi_to_turn_on = ["2.4G"] , auto_close = False ,  print_results = False ):

    self.check_wifi_status()

    wifi_to_turn_on = list(wifi_to_turn_on )

    # To open the guest wifi the regular must be also open
    if Modem.wifi_tuple[2] in wifi_to_turn_on and Modem.wifi_tuple[0] not in wifi_to_turn_on:
      wifi_to_turn_on.append(Modem.wifi_tuple[0])
      
    if Modem.wifi_tuple[3] in wifi_to_turn_on and Modem.wifi_tuple[1] not in wifi_to_turn_on:
      wifi_to_turn_on.append(Modem.wifi_tuple[1])

    while True:
      sorted_wifi_to_turn_on = []

      for wifi in Modem.wifi_tuple:

        if wifi in wifi_to_turn_on  and not self.wifi_status[ Modem.wifi_name_to_int[wifi] ] : 
          # Turn it on 
          sorted_wifi_to_turn_on.append(wifi)
    
      if sorted_wifi_to_turn_on == [] :
        break 

      self.toggle_Wifi(sorted_wifi_to_turn_on , print_results = print_results  )

    if auto_close:
      self.wait_to_close_wifi()
      
  
  def turn_wifi_off (self , wifi_to_turn_off = ( "2.4G" , "5G" , "Guest 2.4G" , "Guest 5G" ) , print_results = False ):

    self.check_wifi_status()


    while True:
      sorted_wifi_to_turn_off = []

      for wifi in reversed(Modem.wifi_tuple):

        if wifi in wifi_to_turn_off  and  self.wifi_status[ Modem.wifi_name_to_int[wifi] ] : 
          # Turn it off
          sorted_wifi_to_turn_off.append(wifi)
    
      if sorted_wifi_to_turn_off == [] :
        break 

      self.toggle_Wifi(sorted_wifi_to_turn_off , print_results = print_results  )


  def wait_to_close_wifi(self , polling_period_min = 2 , inactive_periods = 2 , print_results = False  ):

    print("\nAuto close wifi mode activated.")

    counter = 0 
    # While none is connected and at least inactive_periods*polling_period_min  min have passed turn off all wifi 
    while( True ):
      time.sleep(polling_period_min*60)
      print(f"Polling connected devices (waiting to turn off) , previous inactive periods:{counter}")
      self.check_connected_devices(print_results = print_results)     

      
      if ( self.num_of_conected_devices[1] == 0 and not self.any_whitelisted_device_connected()):
        # If no whitelisted device is conntected consecutive periods with no whitelisted device connected
        counter += 1 
        if ( counter == inactive_periods ):
          break
        
      else:
          # If a whitelisted device is connected reset the counter 
          if counter == 0 :
            print("A whitelisted device is still connected")
          else:
            print("Reseting inactive periods (a whitelisted device has connected)")
            counter = 0 


    print("Closing all wifi")
    self.turn_wifi_off(print_results = print_results)
  
  def any_whitelisted_device_connected(self):

    for device in self.connected_devices:
      if device["Mac"] in self.whitelisted_devices:
        return True
      
    return False

